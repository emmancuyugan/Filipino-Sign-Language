{% extends "base.html" %}
{% block title %}Activity Mode ‚Äì FSL Learning{% endblock %}
{% block content %}

<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
  }

  :root {
    --sunshine: #FFD93D;
    --sky-blue: #4CC9F0;
    --grass-green: #06D6A0;
    --coral: #FF6B9D;
    --lavender: #A78BFA;
    --orange: #FF8C42;
    --deep-blue: #4361EE;
    --white: #FFFFFF;
    --off-white: #FFF8F0;
    --shadow: rgba(0, 0, 0, 0.15);
  }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
    font-weight: 600;
    background: linear-gradient(135deg, #E0F4FF 0%, #FFE5EC 50%, #FFF4E0 100%);
    background-attachment: fixed;
    min-height: 100vh;
    position: relative;
  }

  .bg-shapes {
    position: fixed;
    inset: 0;
    pointer-events: none;
    overflow: hidden;
    z-index: 0;
  }

  .shape {
    position: absolute;
    opacity: 0.15;
    animation: float 20s infinite ease-in-out;
  }

  .shape:nth-child(1) { 
    width: 120px; 
    height: 120px; 
    background: var(--sunshine); 
    border-radius: 30% 70% 70% 30% / 30% 30% 70% 70%;
    top: 10%; 
    left: 5%; 
    animation-delay: 0s;
  }

  .shape:nth-child(2) { 
    width: 90px; 
    height: 90px; 
    background: var(--coral); 
    border-radius: 50%;
    top: 60%; 
    left: 80%; 
    animation-delay: 3s;
  }

  .shape:nth-child(3) { 
    width: 150px; 
    height: 150px; 
    background: var(--grass-green); 
    border-radius: 63% 37% 54% 46% / 55% 48% 52% 45%;
    bottom: 10%; 
    right: 10%; 
    animation-delay: 6s;
  }

  .shape:nth-child(4) { 
    width: 100px; 
    height: 100px; 
    background: var(--lavender); 
    border-radius: 30% 70% 70% 30% / 30% 30% 70% 70%;
    top: 30%; 
    right: 20%; 
    animation-delay: 9s;
  }

  @keyframes float {
    0%, 100% { transform: translate(0, 0) rotate(0deg); }
    25% { transform: translate(20px, -20px) rotate(5deg); }
    50% { transform: translate(-15px, 15px) rotate(-5deg); }
    75% { transform: translate(10px, -10px) rotate(3deg); }
  }

  .app-container {
    position: relative;
    z-index: 1;
    width: 100%;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    padding: 20px;
    gap: 20px;
  }

  .header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: var(--white);
    padding: 15px 25px;
    border-radius: 30px;
    box-shadow: 0 8px 24px var(--shadow);
    animation: slideDown 0.6s ease-out;
  }

  @keyframes slideDown {
    from { transform: translateY(-100%); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
  }

  .logo {
    font-size: 32px;
    font-weight: 700;
    background: linear-gradient(135deg, var(--deep-blue), var(--lavender), var(--coral));
    -webkit-background-clip: text;
    background-clip: text;
    -webkit-text-fill-color: transparent;
    letter-spacing: -1px;
  }

  .header-controls {
    display: flex;
    align-items: center;
    gap: 16px;
  }

  .rec-badge {
    padding: 12px 24px;
    border-radius: 20px;
    font-weight: 700;
    font-size: 20px;
    display: none;
    box-shadow: 0 4px 16px rgba(255, 107, 157, 0.5);
    animation: blink 1.5s infinite;
    background: var(--coral);
    color: var(--white);
  }

  @keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
  }

  .rec-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    background: var(--white);
    border-radius: 50%;
    margin-right: 8px;
    animation: pulse-dot 1.5s infinite;
  }

  @keyframes pulse-dot {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.3); }
  }

  .status-badge {
    padding: 12px 28px;
    background: linear-gradient(135deg, var(--grass-green), var(--sky-blue));
    color: var(--white);
    border-radius: 20px;
    font-weight: 700;
    font-size: 20px;
    box-shadow: 0 4px 12px rgba(6, 214, 160, 0.3);
  }

  .reset-btn {
    padding: 12px 24px;
    background: linear-gradient(135deg, var(--orange), var(--sunshine));
    color: var(--white);
    border: none;
    border-radius: 20px;
    font-size: 18px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 16px rgba(255, 140, 66, 0.3);
  }

  .reset-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 24px rgba(255, 140, 66, 0.4);
  }

  .reset-btn:active {
    transform: translateY(-1px);
  }

  .main-content {
    display: flex;
    gap: 20px;
    flex: 1;
    min-height: 0;
  }

  .camera-section {
    flex: 1;
    position: relative;
    background: var(--white);
    border-radius: 30px;
    box-shadow: 0 8px 32px var(--shadow);
    overflow: hidden;
    animation: scaleIn 0.6s ease-out 0.2s backwards;
  }

  @keyframes scaleIn {
    from { transform: scale(0.9); opacity: 0; }
    to { transform: scale(1); opacity: 1; }
  }

  .camera-wrapper {
    position: relative;
    width: 100%;
    height: 100%;
    background: #000;
    border-radius: 30px;
    overflow: hidden;
  }

  #mainCamera {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 30px;
    transform: scaleX(-1);
  }

  #overlayCanvas {
    position: absolute;
    inset: 0;
    pointer-events: none;
  }

  .prep-overlay {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 64px;
    font-weight: 700;
    color: var(--sunshine);
    display: none;
    z-index: 10;
    text-shadow: 3px 3px 8px #000;
    animation: popIn 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
  }

  @keyframes popIn {
    from { transform: translate(-50%, -50%) scale(0); }
    to { transform: translate(-50%, -50%) scale(1); }
  }

  .timer-bar-container {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 8px;
    background: rgba(255, 255, 255, 0.3);
    border-radius: 0 0 30px 30px;
    overflow: hidden;
  }

  .timer-bar {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, var(--grass-green), var(--sky-blue));
    transition: width 0.1s linear;
  }

  .settings-panel {
    position: absolute;
    top: 20px;
    left: 20px;
    background: rgba(255, 255, 255, 0.95);
    padding: 20px;
    border-radius: 20px;
    box-shadow: 0 4px 16px var(--shadow);
    z-index: 9;
    backdrop-filter: blur(10px);
  }

  .setting-item {
    display: flex;
    align-items: center;
    margin-bottom: 12px;
    font-size: 16px;
    font-weight: 600;
    color: #333;
    cursor: pointer;
    user-select: none;
  }

  .setting-item:last-child {
    margin-bottom: 0;
  }

  .setting-item input[type="checkbox"] {
    width: 24px;
    height: 24px;
    margin-right: 10px;
    cursor: pointer;
    accent-color: var(--grass-green);
  }

  .difficulty-selector {
    position: absolute;
    top: 20px;
    right: 20px;
    z-index: 9;
    background: rgba(255, 255, 255, 0.95);
    border-radius: 20px;
    padding: 12px 20px;
    box-shadow: 0 4px 16px var(--shadow);
    backdrop-filter: blur(10px);
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .difficulty-selector label {
    font-weight: 700;
    color: #333;
    margin: 0;
    font-size: 16px;
  }

  .difficulty-selector select {
    border: 2px solid var(--grass-green);
    border-radius: 12px;
    padding: 8px 16px;
    font-size: 16px;
    font-weight: 600;
    background: white;
    cursor: pointer;
    outline: none;
  }

  .difficulty-selector select:focus {
    border-color: var(--deep-blue);
    box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.2);
  }

  .ghost-badge {
    position: absolute;
    top: 100px;
    right: 20px;
    background: var(--lavender);
    color: var(--white);
    padding: 12px 20px;
    border-radius: 20px;
    font-size: 18px;
    font-weight: 700;
    display: none;
    z-index: 10;
    box-shadow: 0 4px 16px rgba(167, 139, 250, 0.5);
  }

  .ghost-controls {
    position: absolute;
    top: 150px;
    right: 20px;
    display: none;
    flex-direction: column;
    gap: 8px;
    z-index: 10;
  }

  .ghost-btn {
    background: rgba(255, 255, 255, 0.95);
    border: none;
    padding: 8px 16px;
    border-radius: 12px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    box-shadow: 0 2px 8px var(--shadow);
    transition: all 0.2s ease;
  }

  .ghost-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px var(--shadow);
  }

  .control-buttons {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 16px;
    z-index: 10;
  }

  .big-button {
    padding: 20px 48px;
    font-size: 24px;
    font-weight: 700;
    border: none;
    border-radius: 25px;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    box-shadow: 0 6px 20px var(--shadow);
    display: flex;
    align-items: center;
    gap: 10px;
    background: linear-gradient(135deg, var(--grass-green), var(--sky-blue));
    color: var(--white);
  }

  .big-button:hover {
    transform: translateY(-4px) scale(1.05);
    box-shadow: 0 10px 30px var(--shadow);
  }

  .big-button:active {
    transform: translateY(-2px) scale(1.02);
  }

  .sidebar {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 20px;
    animation: slideLeft 0.6s ease-out 0.4s backwards;
  }

  @keyframes slideLeft {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }

  .card {
    background: var(--white);
    border-radius: 25px;
    padding: 25px;
    box-shadow: 0 8px 24px var(--shadow);
    display: flex;
    flex-direction: column;
  }

  .timer-display {
    text-align: center;
    font-weight: 700;
    color: var(--white);
    padding: 16px;
    border-radius: 15px;
    margin-bottom: 20px;
    font-size: 28px;
    background: linear-gradient(135deg, var(--deep-blue), var(--lavender));
    box-shadow: 0 4px 16px rgba(67, 97, 238, 0.3);
    display: none;
  }

  .gesture-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 24px;
  }

  .gesture-label {
    text-align: left;
  }

  .gesture-label h6 {
    font-size: 18px;
    font-weight: 600;
    color: #666;
    margin-bottom: 8px;
  }

  .gesture-name {
    font-size: 36px;
    font-weight: 700;
    background: linear-gradient(135deg, var(--deep-blue), var(--lavender));
    -webkit-background-clip: text;
    background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .result-text {
    font-size: 32px;
    font-weight: 700;
    color: #888;
  }

  .result-text.correct {
    color: var(--grass-green);
  }

  .result-text.incorrect {
    color: var(--coral);
  }

  .progress-section {
    margin-bottom: 20px;
  }

  .progress-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
  }

  .phase-text {
    font-size: 16px;
    color: #666;
    font-weight: 600;
  }

  .frame-count {
    font-size: 16px;
    color: #999;
  }

  .progress-bar-container {
    height: 16px;
    background: var(--off-white);
    border-radius: 10px;
    overflow: hidden;
    border: 2px solid #DDD;
  }

  .progress-bar-fill {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, var(--grass-green), var(--sky-blue));
    transition: width 0.3s ease;
  }

  .assist-section {
    margin-top: 20px;
    padding: 20px;
    background: var(--off-white);
    border-radius: 15px;
    border: 3px dashed #DDD;
    display: none;
  }

  .assist-buttons {
    display: flex;
    gap: 12px;
    margin-bottom: 12px;
  }

  .assist-btn {
    flex: 1;
    padding: 12px 20px;
    border: none;
    border-radius: 12px;
    font-size: 16px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 2px 8px var(--shadow);
  }

  .show-how-btn {
    background: linear-gradient(135deg, var(--lavender), var(--deep-blue));
    color: var(--white);
  }

  .try-again-btn {
    background: linear-gradient(135deg, var(--grass-green), var(--sky-blue));
    color: var(--white);
  }

  .assist-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px var(--shadow);
  }

  .assist-btn:active {
    transform: translateY(0);
  }

  .assist-hint {
    font-size: 14px;
    color: #666;
    text-align: center;
  }

  .stats-section {
    margin-top: auto;
    padding-top: 20px;
    border-top: 3px solid var(--off-white);
  }

  .stats-grid {
    display: flex;
    justify-content: space-around;
    margin-bottom: 20px;
  }

  .stat-item {
    text-align: center;
  }

  .stat-value {
    font-size: 48px;
    font-weight: 700;
    display: block;
    margin-bottom: 8px;
  }

  .stat-value.correct {
    color: var(--grass-green);
  }

  .stat-value.incorrect {
    color: var(--coral);
  }

  .stat-label {
    font-size: 16px;
    color: #666;
    font-weight: 600;
  }

  .info-text {
    text-align: center;
    font-size: 14px;
    color: #999;
    line-height: 1.6;
  }

  .confetti {
    position: fixed;
    width: 10px;
    height: 10px;
    background: var(--sunshine);
    position: absolute;
    animation: confetti-fall 3s linear forwards;
    z-index: 1000;
    pointer-events: none;
  }

  @keyframes confetti-fall {
    to {
      transform: translateY(100vh) rotate(360deg);
      opacity: 0;
    }
  }

  @media (max-width: 1024px) {
    .app-container {
      padding: 15px;
      gap: 15px;
    }

    .logo {
      font-size: 24px;
    }

    .status-badge {
      font-size: 16px;
      padding: 10px 20px;
    }

    .big-button {
      padding: 16px 36px;
      font-size: 20px;
    }

    .gesture-name {
      font-size: 28px;
    }

    .stat-value {
      font-size: 36px;
    }
  }
</style>

<div class="bg-shapes">
  <div class="shape"></div>
  <div class="shape"></div>
  <div class="shape"></div>
  <div class="shape"></div>
</div>

<div class="app-container">
  <div class="header">
    <div class="logo">[Target] Activity Mode</div>
    <div class="header-controls">
      <div class="rec-badge" id="recBadge">
        <span class="rec-dot"></span>REC
      </div>
      <button id="resetBtn" class="reset-btn">‚Ü∫ Reset</button>
      <div class="status-badge" id="stateBadge">State: READY</div>
    </div>
  </div>

  <div class="main-content">
    <div class="camera-section">
      <div class="camera-wrapper">
        <video id="mainCamera" autoplay playsinline muted></video>
        <canvas id="overlayCanvas"></canvas>

        <div class="prep-overlay" id="prepOverlay">Get Ready‚Ä¶</div>

        <div class="timer-bar-container">
          <div class="timer-bar" id="timerBar"></div>
        </div>

        <div class="settings-panel">
          <div class="setting-item">
            <input type="checkbox" id="toggleVisuals" checked>
            <span>[Eye] Hand Markers</span>
          </div>
          <div class="setting-item">
            <input type="checkbox" id="toggleTimer" checked>
            <span>[Timer] Timer</span>
          </div>
          <div class="setting-item">
            <input type="checkbox" id="toggleResults" checked>
            <span>[Note] Results</span>
          </div>
          <div class="setting-item">
            <input type="checkbox" id="toggleSpeed">
            <span>‚ö° Fast Mode</span>
          </div>
        </div>

        <div class="difficulty-selector" id="difficultyOverlay">
          <label>Level:</label>
          <select id="difficultySelect">
            <option value="easy" selected>üü¢ Easy</option>
            <option value="compound">üî¥ Compound</option>
          </select>
        </div>

        <div class="ghost-badge" id="ghostBadge">[Guide] Ghost Helper ON</div>

        <div class="ghost-controls" id="ghostControls">
          <button class="ghost-btn" id="btnSizeDown">Size ‚àí</button>
          <button class="ghost-btn" id="btnSizeUp">Size +</button>
          <button class="ghost-btn" id="btnNudgeUp">Align ‚Üë</button>
          <button class="ghost-btn" id="btnNudgeDown">Align ‚Üì</button>
        </div>

        <div class="control-buttons" id="startOverlay">
          <button class="big-button" id="startBtn">‚ñ∂Ô∏è Start Activity!</button>
        </div>
      </div>
    </div>

    <div class="sidebar">
      <div class="card">
        <div class="timer-display" id="timerOverlay">5</div>

        <div class="gesture-info">
          <div class="gesture-label">
            <h6>Your Challenge:</h6>
            <div class="gesture-name" id="targetLabel">None</div>
          </div>
          <div class="result-text" id="resultText">‚Äî</div>
        </div>

        <div class="progress-section">
          <div class="progress-header">
            <span class="phase-text" id="capturePhase">Idle</span>
            <span class="frame-count"><span id="frameCount">0</span>/48 frames</span>
          </div>
          <div class="progress-bar-container">
            <div class="progress-bar-fill" id="progressBar"></div>
          </div>
        </div>

        <div class="assist-section" id="assistRow">
          <div class="assist-buttons">
            <button class="assist-btn show-how-btn" id="btnShowHow">[Guide] Show me how</button>
            <button class="assist-btn try-again-btn" id="btnTryAgain">‚Üª Try again</button>
          </div>
          <div class="assist-hint" id="assistHint"></div>
        </div>

        <div class="stats-section">
          <div class="stats-grid">
            <div class="stat-item">
              <span class="stat-value correct" id="correctCount">0</span>
              <span class="stat-label">Correct</span>
            </div>
            <div class="stat-item">
              <span class="stat-value incorrect" id="incorrectCount">0</span>
              <span class="stat-label">Incorrect</span>
            </div>
          </div>
          <p class="info-text">Flow: Start ‚Üí Get Ready (1s) ‚Üí Perform (~5s) ‚Üí Predict / Stop.</p>
        </div>
      </div>
    </div>
  </div>
</div>

<script src="{{ url_for('static', filename='mediapipe/camera_utils/camera_utils.js') }}"></script>
<script src="{{ url_for('static', filename='mediapipe/drawing_utils/drawing_utils.js') }}"></script>
<script src="{{ url_for('static', filename='mediapipe/holistic/holistic.js') }}"></script>

<script>
window.addEventListener("load", () => {
  const ENABLE_CONFETTI = false; // keep look, disable expensive confetti
  const NUMBER_SIGNS = ["One","Two","Three","Four","Five"];
  const COLOR_SIGNS  = ["Black","Blue","Green","Orange","Pink","Red","White","Yellow"];
  const FAMILY_SIGNS = ["Daughter","Father","Grandfather","Grandmother","Mother","Son"];
  const RELATIONSHIP_SIGNS = ["Boy","Girl","Man","Woman"];
  const SURVIVAL_SIGNS = ["Correct","Don't Understand","No","Understand","Wrong","Yes"];

  const EASY_ALL_SIGNS = [...NUMBER_SIGNS, ...COLOR_SIGNS, ...FAMILY_SIGNS, ...RELATIONSHIP_SIGNS, ...SURVIVAL_SIGNS];

  function pickEasySign() {
    return EASY_ALL_SIGNS[Math.floor(Math.random() * EASY_ALL_SIGNS.length)];
  }

  function pickCompoundSign(){
    const first = NUMBER_SIGNS[Math.floor(Math.random() * NUMBER_SIGNS.length)];
    const second = COLOR_SIGNS[Math.floor(Math.random()*COLOR_SIGNS.length)];
    return `${first} + ${second}`;
  }

  function celebrate(){
    if(!ENABLE_CONFETTI) return;
    for(let i=0;i<30;i++){
      setTimeout(()=>{
        const confetti=document.createElement('div');
        confetti.className='confetti';
        confetti.style.left=Math.random()*100+'%';
        confetti.style.background=['#FFD93D','#FF6B9D','#06D6A0','#4CC9F0','#A78BFA'][Math.floor(Math.random()*5)];
        confetti.style.animationDelay=Math.random()*0.5+'s';
        document.body.appendChild(confetti);
        setTimeout(()=>confetti.remove(),3000);
      },i*50);
    }
  }

  const videoEl = document.getElementById("mainCamera");
  const canvasEl = document.getElementById("overlayCanvas");
  const ctx = canvasEl.getContext("2d");

  const startBtn = document.getElementById("startBtn");
  const resetBtn = document.getElementById("resetBtn");
  const stateBadge = document.getElementById("stateBadge");
  const targetLabel = document.getElementById("targetLabel");
  const resultText = document.getElementById("resultText");
  const correctCountEl = document.getElementById("correctCount");
  const incorrectCountEl = document.getElementById("incorrectCount");
  const capturePhase = document.getElementById("capturePhase");
  const frameCountEl = document.getElementById("frameCount");
  const progressBar = document.getElementById("progressBar");
  const prepOverlay = document.getElementById("prepOverlay");
  const recBadge = document.getElementById("recBadge");
  const timerBar = document.getElementById("timerBar");
  const difficultySelect = document.getElementById("difficultySelect");

  const toggleVisuals = document.getElementById('toggleVisuals');
  const toggleTimer   = document.getElementById('toggleTimer');
  const toggleResults = document.getElementById('toggleResults');
  const toggleSpeed   = document.getElementById('toggleSpeed');

  let showVisuals = true;
  let showTimer   = true;
  let showResults = true;

  toggleVisuals.onchange = () => { showVisuals = toggleVisuals.checked; };
  toggleTimer.onchange   = () => {
    showTimer = toggleTimer.checked;
    timerBar.style.display = showTimer ? 'block' : 'none';
  };
  toggleResults.onchange = () => {
    showResults = toggleResults.checked;
    resultText.style.display = showResults ? 'block' : 'none';
  };

  const STATE_READY=0, STATE_PREP=1, STATE_CAPTURE=2;
  let state=STATE_READY;
  function setState(s){ state=s; stateBadge.textContent="State: "+["READY","PREP","CAPTURE"][s]; }

  let targetGesture=null, correctCount=0, incorrectCount=0;
  const SEQ_LEN = 48, CAPTURE_MAX = 120;
  const BASE_CAPTURE_MS = 5000;
  let CAPTURE_MS = BASE_CAPTURE_MS;
  let buf=[], running=false, frameSkip=1, frameCounter=0, autoJudge=false, captureStartMs=0;

  function updateGestureDisplay(gesture) {
    targetLabel.textContent = gesture ? gesture : 'None';
  }
  function flattenHand(lms){ if(!lms) return new Float32Array(63); const a=[]; for(let i=0;i<21;i++){ const p=lms[i]; a.push(p.x,p.y,p.z);} return new Float32Array(a); }
  function lm(list,idx){ if(!list||idx>=list.length) return {x:NaN,y:NaN,z:NaN}; return list[idx]; }
  function dist2D(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy)||1e-6; }

  function normalizeGlobal(hand63,anchors){
    if(!hand63||hand63.length!==63||!anchors.L_SH||!anchors.R_SH) return new Float32Array(63);
    const out=new Float32Array(63);
    const Cx=(anchors.L_SH.x+anchors.R_SH.x)/2;
    const Cy=(anchors.L_SH.y+anchors.R_SH.y)/2;
    const Cz=(anchors.L_SH.z+anchors.R_SH.z)/2;
    const scale=Math.max(1e-6,dist2D(anchors.L_SH,anchors.R_SH));
    for(let i=0;i<63;i+=3){
      out[i]=(hand63[i]-Cx)/scale;
      out[i+1]=(hand63[i+1]-Cy)/scale;
      out[i+2]=(hand63[i+2]-Cz)/scale;
    }
    for(let i=0;i<63;i++) out[i]=Math.max(-5,Math.min(5,out[i]));
    return out;
  }

  function derivedAltitudeFeatures(L,R,anchors){
    const out=[];
    const brow_y=0.5*(anchors.brow_r.y+anchors.brow_l.y);
    const SEL=[0,4,8,12,16,20];
    for(const H of [L,R]){
      for(const j of SEL){
        const by=j*3+1, bz=j*3+2;
        const py=H[by], pz=H[bz];
        out.push(py-anchors.chin.y, py-anchors.lip_u.y, py-brow_y, py-anchors.forehead.y, pz-anchors.nose.z);
      }
    }
    return new Float32Array(out);
  }

  function normLabel(s){
    if(!s) return "";
    const x = String(s).toLowerCase().replace(/[^a-z0-9]+/g,'');
    const map = {
      "1":"one","2":"two","3":"three","4":"four","5":"five",
      "grandmother":"grandmother","grandma":"grandmother","lola":"grandmother",
      "grandfather":"grandfather","grandpa":"grandfather","lolo":"grandfather",
      "mom":"mother","mother":"mother","nanay":"mother",
      "dad":"father","father":"father","tatay":"father",
      "boy":"boy","girl":"girl","man":"man","woman":"woman",
      "son":"son","daughter":"daughter",
      "black":"black","blue":"blue","green":"green","orange":"orange","pink":"pink","red":"red","white":"white","yellow":"yellow",
      "correct":"correct","dontunderstand":"dontunderstand","no":"no","understand":"understand","wrong":"wrong","yes":"yes"
    };
    return map[x] || x;
  }
  function inferCategory(label){
    const l = normLabel(label);
    if (["one","two","three","four","five"].includes(l)) return "numbers";
    if (["daughter","father","grandfather","grandmother","mother","son"].includes(l)) return "family";
    if (["boy","girl","man","woman"].includes(l)) return "relationship";
    if (["correct","dontunderstand","no","understand","wrong","yes"].includes(l)) return "survival";
    return "colors";
  }

  function packFeature(res){
    const pose=res.poseLandmarks||[], face=res.faceLandmarks||[];
    const anchors={};
    anchors.L_SH=lm(pose,11); anchors.R_SH=lm(pose,12);
    anchors.nose=lm(face,1); anchors.forehead=lm(face,10);
    anchors.lip_u=lm(face,13); anchors.brow_r=lm(face,65); anchors.brow_l=lm(face,295);
    anchors.chin=lm(face,152);
    const Lh=res.rightHandLandmarks?flattenHand(res.rightHandLandmarks):null;
    const Rh=res.leftHandLandmarks?flattenHand(res.leftHandLandmarks):null;
    const lf=Lh?1:0, rf=Rh?1:0;
    if(!Lh && !Rh) return null;
    const L=normalizeGlobal(Lh,anchors), R=normalizeGlobal(Rh,anchors);
    const alt=derivedAltitudeFeatures(L,R,anchors);
    return new Float32Array([...L,...R,...alt,lf,rf]);
  }

  function temporalFix(frames,seqLen){
    if(frames.length<=seqLen){
      const pad=Array.from({length:seqLen-frames.length},()=>frames[frames.length-1]);
      return frames.concat(pad);
    }
    const scores=new Array(frames.length).fill(0);
    for(let i=1;i<frames.length;i++){
      const f0=frames[i-1], f1=frames[i]; if(!f0||!f1) continue;
      let motion=0; for(let j=0;j<f0.length-2;j++) motion+=Math.abs(f1[j]-f0[j]);
      motion/=(f0.length-2);
      const presence=f1[f1.length-2]+f1[f1.length-1];
      scores[i]=0.7*motion+0.3*presence;
    }
    const W=Math.min(40,frames.length);
    let bestStart=0, bestSum=-1e9, runSum=0;
    for(let i=0;i<W;i++) runSum+=scores[i]; bestSum=runSum;
    for(let i=1;i<=scores.length-W;i++){
      runSum+=scores[i+W-1]-scores[i-1];
      if(runSum>bestSum){bestSum=runSum; bestStart=i;}
    }
    const selected=frames.slice(bestStart,bestStart+W);
    const step=selected.length/seqLen;
    const aligned=[];
    for(let i=0;i<seqLen;i++){
      const idx=Math.min(Math.floor(i*step),selected.length-1);
      aligned.push(selected[idx]);
    }
    return aligned;
  }

  function updateBuffer(f){
    if(buf.length<CAPTURE_MAX) buf.push(f);
    else { buf.shift(); buf.push(f); }
    frameCountEl.textContent=Math.min(buf.length,SEQ_LEN);
    progressBar.style.width=Math.min(100,Math.round((buf.length/CAPTURE_MAX)*100))+"%";
    if(state===STATE_CAPTURE && captureStartMs){
      const t=Math.max(0,Math.min(1,(Date.now()-captureStartMs)/CAPTURE_MS));
      if (showTimer) timerBar.style.width=(t*100).toFixed(1)+'%';
    } else {
      timerBar.style.width='0%';
    }
    if(buf.length>=CAPTURE_MAX && !autoJudge){
      autoJudge=true; setTimeout(()=>stopAndPredict(),200);
    }
  }

  const PREDICT_URL = location.origin + '/predict';
  async function callPredict(sequence) {
    const payload = { method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify({ sequence }) };
    const res = await fetch(PREDICT_URL, payload);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return await res.json();
  }

  function extractPredictedLabel(j){
    let predicted = j?.prediction || j?.label || j?.pred?.label || j?.pred?.class;
    if (!predicted && Array.isArray(j?.topk) && j.topk.length) {
      predicted = j.topk[0].label || j.topk[0].class || j.topk[0].name;
    }
    if (typeof predicted === "string" && predicted.includes("_")) {
      predicted = predicted.split("_").pop();
    }
    return normLabel(predicted);
  }

  async function predictOnce(silent=false){
    if (buf.length < 20) {
      if (!silent) alert('Not enough data.');
      return { predicted: null, raw: null };
    }
    const fixed = temporalFix(buf, SEQ_LEN);
    const seq = fixed.flatMap(f => Array.from(f));

    try {
      const j = await callPredict(seq);
      const predicted = extractPredictedLabel(j);

      if (difficultySelect.value !== "compound" && !silent) {
        const target = normLabel(targetGesture || '');
        if (predicted && target && predicted === target) {
          correctCount++;
          resultText.textContent = '‚úì Correct!';
          resultText.className = 'result-text correct';
          correctCountEl.textContent = String(correctCount);
          document.getElementById("assistRow").style.display = 'none';
          celebrate();
        } else {
          incorrectCount++;
          resultText.textContent = '‚úó Incorrect';
          resultText.className = 'result-text incorrect';
          incorrectCountEl.textContent = String(incorrectCount);
          const assistRow = document.getElementById("assistRow");
          const assistHint = document.getElementById("assistHint");
          assistRow.style.display = 'block';
          assistHint.textContent = 'Watch the overlay, then try again.';
        }
      }
      return { predicted, raw: j };
    } catch (e) {
      console.error(e);
      if (!silent) {
        resultText.textContent = '‚ö†Ô∏è Prediction error';
        resultText.className = 'result-text';
        const assistRow = document.getElementById("assistRow");
        const assistHint = document.getElementById("assistHint");
        assistRow.style.display = 'block';
        assistHint.textContent = 'Check that the backend is running and reachable.';
      }
      return { predicted: null, raw: null };
    }
  }

  async function stopAndPredict(isHalfway = false) {
    if (state !== STATE_CAPTURE && state !== STATE_PREP) return;

    if (isHalfway) {
      if (autoJudge === "lock" || autoJudge === "half_done") return;
      autoJudge = "lock";

      capturePhase.textContent = "‚úì First sign complete ‚Äî processing...";
      const firstResult = await predictOnce(true);
      window.firstCompoundResult = firstResult;

      const [firstExpected, secondExpected] = (targetGesture || "")
        .split("+")
        .map(s => normLabel(s.trim()));

      const firstPred = normLabel(firstResult?.predicted);
      if (firstPred === firstExpected) {
        resultText.textContent = `‚úì First sign correct (${firstExpected})`;
        resultText.className = "result-text correct";
      } else {
        resultText.textContent = `‚úó First sign incorrect ‚Äî expected ${firstExpected}`;
        resultText.className = "result-text incorrect";
      }

      buf = [];
      frameCounter = 0;
      frameCountEl.textContent = "0";
      progressBar.style.width = "0%";
      timerBar.style.width = "0%";

      setTimeout(() => {
        autoJudge = "half_done";
        capturePhase.textContent = "Perform second sign (~5 s)‚Ä¶";
        captureStartMs = Date.now();
      }, 1200);

      return;
    }

    if (difficultySelect.value === "compound") {
      if (autoJudge === "done") return;
      autoJudge = "done";

      running = false;
      recBadge.style.display = "none";
      capturePhase.textContent = "Processing results...";
      try { await camera.stop(); } catch(_) {}

      const secondResult = await predictOnce(true);
      const firstResult = window.firstCompoundResult || {};

      const [firstExpected, secondExpected] = (targetGesture || "")
        .split("+")
        .map(s => normLabel(s.trim()));

      const firstPred = normLabel(firstResult?.predicted);
      const secondPred = normLabel(secondResult?.predicted);

      let summary = "";
      if (firstPred === firstExpected && secondPred === secondExpected) {
        summary = `‚úì Compound correct: ${firstExpected} + ${secondExpected}`;
        resultText.className = "result-text correct";
        correctCount++;
        celebrate();
      } else if (firstPred === firstExpected && secondPred !== secondExpected) {
        summary = `‚úó Second sign incorrect ‚Äî expected ${secondExpected}`;
        resultText.className = "result-text incorrect";
        incorrectCount++;
      } else if (firstPred !== firstExpected && secondPred === secondExpected) {
        summary = `‚úó First sign incorrect ‚Äî expected ${firstExpected}`;
        resultText.className = "result-text incorrect";
        incorrectCount++;
      } else {
        summary = `‚úó Both signs incorrect`;
        resultText.className = "result-text incorrect";
        incorrectCount++;
      }

      resultText.textContent = summary;
      correctCountEl.textContent = String(correctCount);
      incorrectCountEl.textContent = String(incorrectCount);

      stopNumericTimer();
      setState(STATE_READY);
      capturePhase.textContent = "Idle";
      startBtn.style.display = "inline-block";
      timerBar.style.width = "0%";
      return;
    }

    running = false;
    recBadge.style.display = "none";
    await predictOnce(false);
    setState(STATE_READY);
    capturePhase.textContent = "Idle";
    startBtn.style.display = "inline-block";
    timerBar.style.width = "0%";
  }

  const HAND_CONN = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],[0,17],[17,18],[18,19],[19,20]];
  let ghostEnabled=false, ghostFrames=null, ghostIdx=0, ghostReady=false;
  let previewMode=false;
  let scaleMultiplier = 1.08;
  let yOffset = -0.08;
  let ghostPlaybackSpeed = 0.25;

  const ghostBadge = document.getElementById("ghostBadge");
  const ghostControls = document.getElementById("ghostControls");
  const btnSizeDown = document.getElementById("btnSizeDown");
  const btnSizeUp = document.getElementById("btnSizeUp");
  const btnNudgeUp = document.getElementById("btnNudgeUp");
  const btnNudgeDown = document.getElementById("btnNudgeDown");

  function showGhostUI(show){
    ghostBadge.style.display = show ? 'inline-block' : 'none';
    ghostControls.style.display = show ? 'flex' : 'none';
  }

  btnSizeUp.onclick    = () => { scaleMultiplier = Math.min(1.6, scaleMultiplier + 0.04); };
  btnSizeDown.onclick  = () => { scaleMultiplier = Math.max(0.7, scaleMultiplier - 0.04); };
  btnNudgeUp.onclick   = () => { yOffset -= 0.01; };
  btnNudgeDown.onclick = () => { yOffset += 0.01; };

  window.addEventListener('keydown', (e) => {
    if(!ghostEnabled) return;
    if(e.key === '=' || e.key === '+') { scaleMultiplier = Math.min(1.6, scaleMultiplier + 0.04); }
    if(e.key === '-') { scaleMultiplier = Math.max(0.7, scaleMultiplier - 0.04); }
    if(e.key === 'ArrowUp') { yOffset -= 0.01; }
    if(e.key === 'ArrowDown') { yOffset += 0.01; }
  });

  function anchorsValid(a){
    if(!a || !a.L_SH || !a.R_SH) return false;
    return Number.isFinite(a.L_SH.x) && Number.isFinite(a.R_SH.x) && Number.isFinite(a.L_SH.y) && Number.isFinite(a.R_SH.y) && dist2D(a.L_SH, a.R_SH) > 0.02;
  }

  async function startPreviewIfNeeded(){
    if(state!==STATE_CAPTURE && !previewMode){
      previewMode=true;
      capturePhase.textContent='Preview (overlay)‚Ä¶';
      setState(STATE_READY);
      timerBar.style.width='0%';
      await camera.start();
    }
  }
  async function stopPreviewIfAny(){
    if(previewMode){
      previewMode=false;
      capturePhase.textContent='Idle';
      try{ await camera.stop(); }catch(_){}
    }
  }

  async function findDemoUrl(cat, key){
    const STATIC_BASE = (window.location.origin + '/static/video').replace(/\/+$/, '');
    const names=[];
    for(let i=1;i<=10;i++) names.push(key + '_' + String(i).padStart(2,'0') + '.mp4');
    names.push(key + '.mp4');
    for(const n of names){
      const url = STATIC_BASE + '/' + cat + '/' + n;
      try{
        const r=await fetch(url,{method:'HEAD',cache:'no-store'});
        if(r.ok) return url;
      }catch(_){}
    }
    return null;
  }

  function drawGhostHand(norm63, anchors, ctx, color){
    if (!norm63) return;
    const baseScale=Math.max(1e-6, dist2D(anchors.L_SH, anchors.R_SH));
    const scale = baseScale * scaleMultiplier;
    const Cx=(anchors.L_SH.x+anchors.R_SH.x)/2;
    const Cy=(anchors.L_SH.y+anchors.R_SH.y)/2 + yOffset;
    const pts=[];
    for (let i=0;i<63;i+=3){
      const x = norm63[i  ]*scale + Cx;
      const y = norm63[i+1]*scale + Cy;
      pts.push({x:x, y:y});
    }
    ctx.save();
    ctx.globalCompositeOperation='screen';
    ctx.strokeStyle=color;
    ctx.lineWidth=6;
    ctx.fillStyle=color;
    ctx.shadowBlur=18;
    ctx.shadowColor=color;
    const W=canvasEl.width, H=canvasEl.height;
    for (let k=0;k<HAND_CONN.length;k++){
      const a=HAND_CONN[k][0], b=HAND_CONN[k][1];
      const p=pts[a], q=pts[b];
      ctx.beginPath(); ctx.moveTo(p.x*W, p.y*H); ctx.lineTo(q.x*W, q.y*H); ctx.stroke();
    }
    for (let i=0;i<pts.length;i++){
      const p=pts[i]; ctx.beginPath(); ctx.arc(p.x*W, p.y*H, 8, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  async function loadGhostFor(label){
    const cat=inferCategory(label);
    const key=normLabel(label);
    const assistHint = document.getElementById("assistHint");
    assistHint.textContent='Loading demo overlay‚Ä¶';
    showGhostUI(false);
    const url=await findDemoUrl(cat,key);
    if(!url){ assistHint.textContent='No demo found for '+cat+'/'+key; ghostReady=false; return false; }
    const v=document.createElement('video');
    v.src=url; v.muted=true; v.playsInline=true; v.crossOrigin='anonymous';
    await new Promise((resolve,reject)=>{ v.onloadedmetadata=resolve; v.onerror=()=>reject(new Error('Video error')); });
    const ghostHolistic=new Holistic({locateFile: (f) => `/static/mediapipe/holistic/${f}`});
    ghostHolistic.setOptions({selfieMode:false,modelComplexity:1,smoothLandmarks:true,refineFaceLandmarks:false,minDetectionConfidence:0.5,minTrackingConfidence:0.5});
    ghostFrames=[];
    ghostHolistic.onResults(res=>{
      const pose=res.poseLandmarks||[], face=res.faceLandmarks||[];
      const anchors={};
      anchors.L_SH=lm(pose,11); anchors.R_SH=lm(pose,12);
      anchors.nose=lm(face,1); anchors.forehead=lm(face,10);
      anchors.lip_u=lm(face,13); anchors.brow_r=lm(face,65); anchors.brow_l=lm(face,295);
      anchors.chin=lm(face,152);
      const Lh=res.rightHandLandmarks?flattenHand(res.rightHandLandmarks):null;
      const Rh=res.leftHandLandmarks?flattenHand(res.leftHandLandmarks):null;
      if(!Lh && !Rh) return;
      const L=Lh?normalizeGlobal(Lh,anchors):new Float32Array(63);
      const R=Rh?normalizeGlobal(Rh,anchors):new Float32Array(63);
      ghostFrames.push({L:L, R:R});
    });
    const total=Math.min(24, Math.max(12, Math.floor(v.duration*6)));
    for(let i=0;i<total;i++){
      v.currentTime = (v.duration * i)/total;
      await new Promise(function(r){ v.onseeked=r; });
      await ghostHolistic.send({image:v});
    }
    ghostReady = ghostFrames.length>0;
    assistHint.textContent = ghostReady ? 'Overlay loaded. Use Size/Align controls if needed.' : 'No hands detected in demo video.';
    return ghostReady;
  }

  let ghostTimer=null;
  const GHOST_DURATION_MS=12000;

  document.getElementById("btnShowHow").onclick = async () => {
    if(!targetGesture) return;
    ghostEnabled=true; ghostFrames=null; ghostReady=false; ghostIdx=0;
    await startPreviewIfNeeded();
    const ok = await loadGhostFor(targetGesture);
    if (ok){
      showGhostUI(true);
      if (ghostTimer) clearTimeout(ghostTimer);
      ghostTimer=setTimeout(() => {
        ghostEnabled=false; showGhostUI(false); document.getElementById("assistHint").textContent='';
      }, GHOST_DURATION_MS);
    }else{
      ghostEnabled=false; showGhostUI(false);
    }
  };

  document.getElementById("btnTryAgain").onclick = async () => {
    ghostEnabled=false; showGhostUI(false); document.getElementById("assistHint").textContent='';
    await stopPreviewIfAny();
    resultText.textContent='‚Äî';
    startBtn.click();
  };

  const holistic=new Holistic({locateFile: (f) => `/static/mediapipe/holistic/${f}`});
  holistic.setOptions({selfieMode:false,modelComplexity:2,smoothLandmarks:true,refineFaceLandmarks:false,minDetectionConfidence:0.55,minTrackingConfidence:0.55});

  holistic.onResults(function(res){
    ctx.save();
    ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
    ctx.drawImage(res.image, 0, 0, canvasEl.width, canvasEl.height);

    const pose = res.poseLandmarks || [];
    const face = res.faceLandmarks || [];
    const anchors = {};
    anchors.L_SH = lm(pose, 11);
    anchors.R_SH = lm(pose, 12);
    anchors.nose = lm(face, 1);
    anchors.forehead = lm(face, 10);
    anchors.lip_u = lm(face, 13);
    anchors.brow_r = lm(face, 65);
    anchors.brow_l = lm(face, 295);
    anchors.chin = lm(face, 152);

    if (showVisuals) {
      const RH = res.rightHandLandmarks;
      const LH = res.leftHandLandmarks;

      const drawBox = (landmarks, color) => {
        if (!landmarks || !landmarks.length) return;
        let minX = 1, minY = 1, maxX = 0, maxY = 0;
        landmarks.forEach(p => {
          minX = Math.min(minX, p.x);
          maxX = Math.max(maxX, p.x);
          minY = Math.min(minY, p.y);
          maxY = Math.max(maxY, p.y);
        });
        ctx.strokeStyle = color;
        ctx.lineWidth = 4;
        ctx.strokeRect(
          minX * canvasEl.width,
          minY * canvasEl.height,
          (maxX - minX) * canvasEl.width,
          (maxY - minY) * canvasEl.height
        );
        ctx.fillStyle = color;
        landmarks.forEach(p => {
          ctx.beginPath();
          ctx.arc(p.x * canvasEl.width, p.y * canvasEl.height, 6, 0, 2 * Math.PI);
          ctx.fill();
        });
      };

      if (RH) drawBox(RH, 'rgba(6,214,160,0.9)');
      if (LH) drawBox(LH, 'rgba(255,107,157,0.9)');
    }

    if (ghostEnabled && ghostReady && anchorsValid(anchors) && ghostFrames && ghostFrames.length){
      const total=ghostFrames.length;
      ghostIdx+=ghostPlaybackSpeed; if(ghostIdx>=total) ghostIdx=0;
      const frameA=ghostFrames[Math.floor(ghostIdx)%total];
      const frameB=ghostFrames[Math.floor(ghostIdx+1)%total];
      const t=ghostIdx%1;
      const L=new Float32Array(63); const R=new Float32Array(63);
      for(let i=0;i<63;i++){L[i]=(1-t)*frameA.L[i]+t*frameB.L[i]; R[i]=(1-t)*frameA.R[i]+t*frameB.R[i];}
      drawGhostHand(L, anchors, ctx, 'rgba(167,139,250,0.85)');
      drawGhostHand(R, anchors, ctx, 'rgba(76,201,240,0.85)');
      showGhostUI(true);
    } else if (ghostEnabled && !anchorsValid(anchors)) {
      const assistHint = document.getElementById("assistHint");
      assistHint.textContent = 'Step back so both shoulders are visible.';
      showGhostUI(false);
    } else {
      showGhostUI(false);
    }

    ctx.restore();

    if (running && state === STATE_CAPTURE) {
      frameCounter++;
      if (frameCounter % frameSkip === 0) {
        const feat = packFeature(res);
        if (feat) updateBuffer(feat);
      }

      const elapsed = Date.now() - captureStartMs;

      if (difficultySelect.value === "compound") {
        if (elapsed >= BASE_CAPTURE_MS && autoJudge === false) {
          stopAndPredict(true);
        } else if (elapsed >= BASE_CAPTURE_MS * 2 && autoJudge === "half_done") {
          stopAndPredict(false);
        }
      } else if (elapsed >= BASE_CAPTURE_MS && autoJudge === false) {
        autoJudge = true;
        setTimeout(() => stopAndPredict(), 80);
      }
    }
  });

  const camera=new Camera(videoEl,{ onFrame:async function(){ await holistic.send({image:videoEl}); }, width:640, height:480 });

  const originalStart = () => {
    const diff = difficultySelect.value;
    const fastMode = toggleSpeed.checked;
    CAPTURE_MS = fastMode ? 3000 : ((diff === "compound") ? BASE_CAPTURE_MS * 2 : BASE_CAPTURE_MS);

    if (diff === "easy") {
      targetGesture = pickEasySign();
      updateGestureDisplay(`${targetGesture} (Easy)`);
    } else if (diff === "compound") {
      targetGesture = pickCompoundSign();
      updateGestureDisplay(`${targetGesture} (Compound)`);
    }

    buf = [];
    frameCounter = 0;
    autoJudge = false;
    setState(STATE_PREP);

    prepOverlay.style.display = "block";
    recBadge.style.display = "none";
    startBtn.style.display = "none";
    resultText.textContent = "‚Äî";
    capturePhase.textContent = "Get Ready‚Ä¶";
    running = true;
    camera.start();
    timerBar.style.width = "0%";
    document.getElementById("assistRow").style.display = "none";

    setTimeout(function () {
      setState(STATE_CAPTURE);
      prepOverlay.style.display = "none";
      recBadge.style.display = "inline-block";
      capturePhase.textContent = (diff === "compound") ? "Perform first sign (~5 s)‚Ä¶" : "Perform Now (~5 s)‚Ä¶";
      captureStartMs = Date.now();
      startNumericTimer(toggleSpeed.checked);
    }, 1000);
  };

  startBtn.onclick = async () => {
    document.body.classList.add('camera-running'); await stopPreviewIfAny(); originalStart(); };

  const originalReset = () => {
    correctCount=0; incorrectCount=0;
    correctCountEl.textContent='0'; incorrectCountEl.textContent='0';
    targetGesture=null; updateGestureDisplay(null); resultText.textContent='‚Äî';
    document.getElementById("assistRow").style.display='none';
    document.getElementById("assistHint").textContent='';
    ghostEnabled=false; ghostFrames=null; ghostIdx=0; ghostReady=false; showGhostUI(false);
    buf=[]; frameCounter=0; frameCountEl.textContent='0'; progressBar.style.width='0%'; timerBar.style.width='0%';
    capturePhase.textContent='Idle'; setState(STATE_READY);
    stopNumericTimer();
    startBtn.style.display='inline-block';
    scaleMultiplier=1.08; yOffset=-0.02; ghostPlaybackSpeed=0.5;
  };
  resetBtn.onclick = async () => {
    document.body.classList.remove('camera-running'); await stopPreviewIfAny(); originalReset(); };

  let tickInterval = null;
  const timerOverlay = document.getElementById("timerOverlay");

  function startNumericTimer(fastMode) {
    if (!showTimer) return;
    clearInterval(tickInterval);

    let countdown = fastMode ? 3 : 5;
    timerOverlay.textContent = countdown;
    timerOverlay.style.display = "block";
    timerOverlay.style.background = "linear-gradient(135deg, var(--deep-blue), var(--lavender))";

    tickInterval = setInterval(() => {
      countdown--;
      if (countdown <= 0) {
        timerOverlay.textContent = "0";
        timerOverlay.style.background = "linear-gradient(135deg, var(--coral), var(--orange))";
        clearInterval(tickInterval);
        setTimeout(() => (timerOverlay.style.display = "none"), 600);
        return;
      }
      timerOverlay.textContent = countdown;
      if (countdown <= 1) timerOverlay.style.background = "linear-gradient(135deg, var(--coral), var(--orange))";
      else if (countdown <= 2) timerOverlay.style.background = "linear-gradient(135deg, var(--orange), var(--sunshine))";
      else timerOverlay.style.background = "linear-gradient(135deg, var(--deep-blue), var(--lavender))";
    }, 1000);
  }

  function stopNumericTimer() {
    clearInterval(tickInterval);
    timerOverlay.style.display = "none";
  }

  function resize(){
    canvasEl.width = videoEl.clientWidth;
    canvasEl.height = videoEl.clientHeight;
  }
  new ResizeObserver(resize).observe(videoEl);
  resize();
});
</script>

{% endblock %}
</document_content>