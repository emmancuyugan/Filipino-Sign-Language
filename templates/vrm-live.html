{% extends "base.html" %}
{% block title %}VRM Live{% endblock %}

{% block content %}
<style>
  #vrm-container {
    width: 100%;
    height: 80vh;
    background: #111;
  }
</style>

<h1 style="color:white">VRM Live</h1>
<div id="vrm-container"></div>

<!-- ✅ This makes "three" resolvable for three-vrm.module.js -->
<script type="importmap">
{
  "imports": {
    "three": "/static/vendor/three/three.module.js",
    "three/addons/": "/static/vendor/three/examples/jsm/",
    "@pixiv/three-vrm": "/static/vendor/three/three-vrm.module.js"
  }
}
</script>

<script type="module">
  import * as THREE from "three";
  import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";
  import { VRMLoaderPlugin } from "@pixiv/three-vrm";

  const container = document.getElementById("vrm-container");

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x222222);

  const camera = new THREE.PerspectiveCamera(
    30,
    container.clientWidth / container.clientHeight,
    0.1,
    100
  );
  camera.position.set(0, 1.4, 4.0);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(container.clientWidth, container.clientHeight);
  container.appendChild(renderer.domElement);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.target.set(0, 1.4, 0);
  controls.update();

  // Optional: makes it harder to zoom into the face accidentally
  controls.minDistance = 0.5;
  controls.maxDistance = 10;

  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(1, 2, 1);
  scene.add(light);

  const loader = new GLTFLoader();
  loader.register((parser) => new VRMLoaderPlugin(parser));

  // ✅ VRM update loop support
  let currentVrm = null;
  const clock = new THREE.Clock();

  loader.load(
    "/static/models/boy.vrm",
    (gltf) => {
      currentVrm = gltf.userData.vrm;

      scene.add(currentVrm.scene);

      // Face the camera
      currentVrm.scene.rotation.y = Math.PI;

      // Keep scale at 1 for now (works fine when we auto-frame)
      currentVrm.scene.position.set(0, 0, 0);
      currentVrm.scene.scale.setScalar(1.0);

      // Center by hips (optional but good)
      const hips = currentVrm.humanoid?.getBoneNode("hips");
      if (hips) {
        currentVrm.scene.position.y -= hips.position.y;
      }

      // --- AUTO FRAME CAMERA ---
      const box = new THREE.Box3().setFromObject(currentVrm.scene);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());

      // Move controls target to the model center
      controls.target.copy(center);
      controls.update();

      // Fit camera to model
      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = THREE.MathUtils.degToRad(camera.fov);
      let cameraZ = Math.abs((maxDim / 2) / Math.tan(fov / 2));

      cameraZ *= 1.6; // zoom-out padding (tweak 1.2–2.0)

      camera.position.set(center.x, center.y + maxDim * 0.15, center.z + cameraZ);

      // Good clipping planes
      camera.near = maxDim / 100;
      camera.far = maxDim * 100;
      camera.updateProjectionMatrix();

      console.log("VRM loaded + framed", { size, center });
    },
    undefined,
    (err) => console.error("VRM load error:", err)
  );

  function onResize() {
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, container.clientHeight);
  }
  window.addEventListener("resize", onResize);

  function animate() {
    requestAnimationFrame(animate);

    const delta = clock.getDelta();
    if (currentVrm) currentVrm.update(delta);

    controls.update();
    renderer.render(scene, camera);
  }
  animate();
</script>
{% endblock %}
